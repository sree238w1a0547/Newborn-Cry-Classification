# -*- coding: utf-8 -*-
"""BabyCryAnalysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KrJI2K5dusAPXRtyIaB0WOI_kIpC7ucr
"""

import os

print("Files in /content:")
print(os.listdir("/content"))

import zipfile
import os

zip_path = "/content/dataset.zip"
extract_path = "/content/dataset"

os.makedirs(extract_path, exist_ok=True)
print("Dataset folder created:", extract_path)

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

print("Extraction completed")

print("Contents of /content/dataset:")
print(os.listdir(extract_path))

dataset_path = "/content/dataset/donateacry_corpus"

print("Final dataset path contents:")
print(os.listdir(dataset_path))

!pip install librosa gradio seaborn scikit-learn

import os
import numpy as np
import librosa

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.pipeline import make_pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix

import seaborn as sns
import matplotlib.pyplot as plt

DATASET_PATH = "/content/dataset/donateacry_corpus"

def extract_features(file_path):
    audio, sr = librosa.load(file_path, duration=3, offset=0.5)
    mfccs = librosa.feature.mfcc(y=audio, sr=sr, n_mfcc=40)
    return np.mean(mfccs.T, axis=0)

X = []
y = []

for label in os.listdir(DATASET_PATH):
    label_path = os.path.join(DATASET_PATH, label)
    if os.path.isdir(label_path):
        for file in os.listdir(label_path):
            if file.endswith(".wav"):
                file_path = os.path.join(label_path, file)
                features = extract_features(file_path)
                X.append(features)
                y.append(label)

X = np.array(X)
y = np.array(y)

print("X shape:", X.shape)
print("y shape:", y.shape)

encoder = LabelEncoder()
y = encoder.fit_transform(y)

class_names = encoder.classes_
print("Classes:", class_names)

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from sklearn.ensemble import RandomForestClassifier

X_train, X_test, y_train, y_test = train_test_split(
    X,
    y,
    test_size=0.2,
    random_state=7
)

# Build model pipeline
model = make_pipeline(
    StandardScaler(),
    RandomForestClassifier(
        n_estimators=400,
        random_state=7,
        n_jobs=-1
    )
)

# Train model
model.fit(X_train, y_train)

print("‚úÖ Model trained successfully")

from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# Prediction
y_pred = model.predict(X_test)

# Classification report
print("Classification Report:\n")
print(classification_report(y_test, y_pred, target_names=class_names))

# Confusion matrix
cm = confusion_matrix(y_test, y_pred)

plt.figure(figsize=(6, 5))
sns.heatmap(
    cm,
    annot=True,
    fmt="d",
    cmap="Blues",
    xticklabels=class_names,
    yticklabels=class_names
)
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

import gradio as gr

# Cry reasons and home remedies
cry_remedies = {
    "belly_pain": {
        "reason": "Baby may have gas or stomach discomfort.",
        "remedy": "Gently massage the tummy, burp the baby, and keep the baby upright after feeding."
    },
    "burping": {
        "reason": "Baby needs to burp after feeding.",
        "remedy": "Hold the baby upright and gently pat the back until burping occurs."
    },
    "discomfort": {
        "reason": "Baby may feel uncomfortable due to wet diaper or temperature.",
        "remedy": "Change diaper and ensure comfortable room temperature and clothing."
    },
    "hungry": {
        "reason": "Baby is hungry and needs feeding.",
        "remedy": "Breastfeed or bottle-feed the baby with proper posture."
    },
    "tired": {
        "reason": "Baby is tired or overstimulated.",
        "remedy": "Reduce noise and light, gently rock the baby, and help them sleep."
    }
}

def predict_audio(file):
    try:
        if file is None:
            return "‚ùå Please upload a baby cry audio file (.wav)."

        # Feature extraction
        features = extract_features(file)

        # Model prediction
        pred = model.predict([features])[0]
        label = encoder.inverse_transform([pred])[0]

        label_key = label.strip().lower()

        info = cry_remedies.get(
            label_key,
            {
                "reason": "General discomfort or unclear reason.",
                "remedy": "Comfort the baby and consult a pediatrician if crying persists."
            }
        )

        result = (
            f"üçº Predicted Cry Type: {label}\n\n"
            f"üìå Possible Reason:\n{info['reason']}\n\n"
            f"üè† Home Remedy:\n{info['remedy']}\n\n"
            "‚ö†Ô∏è Note: These are general care tips and not a substitute for medical advice."
        )

        return result

    except Exception as e:
        return f"‚ùå Error during prediction:\n{str(e)}"


ui = gr.Interface(
    fn=predict_audio,
    inputs=gr.Audio(type="filepath", label="Upload Baby Cry (.wav)"),
    outputs=gr.Textbox(label="Prediction Result", lines=10),
    title="Newborn Cry Classification & Home Care Assistant",
    description="Upload a baby cry audio and click Submit to identify the cry type and get safe home-care suggestions.",
    submit_btn="Submit",
    clear_btn="Clear"
)

ui.launch(share=True, debug=False)